# 第二章 JAVA内存区域

---

## 内存模型（最重点）
图一占位（p60）
### 1 程序计数器PC

1. 分支、循环、异常、多线程等都依赖PC，线程私有
2. native方法时，值为空undefined
3. 唯一一个没有定义OOM情况的内存区

### 2 JAVA虚拟机栈

1. 线程私有，每个线程对应一个栈帧
2. 栈帧用于存储局部变量表、操作数栈、动态链接、方法出口
3. 局部变量表包括基本数据类型和对象引用，在编译期间完成内存分配，运行期间大小不会改变
4. 有stackoverflow异常和outofmemory异常

### 3 本地方法栈

1. 类似java虚拟机栈，只不过此栈执行native方法
2. 不同虚拟机实现不同，某些jvm将java栈和native栈合并
3. 有stackoverflow异常和outofmemory异常

### 4 JAVA堆

1. 所有线程共享，用于存放对象实例，虚拟机启动时创建
2. 垃圾回收的主要区域，又称"GC堆"
3. 逻辑连续即可，有OOM异常

### 5 方法区

1. 线程共享，用于存储jvm加载的类信息、常量、静态变量
2. 属于JAVA堆的逻辑部分，内存管理方式使用“永久代”实现
4. 方法区虽然别名“永久代”，但是也是有内存回收，回收针对常量池和类的卸载

### 6 运行时常量池

1. 是方法区的一部分，在类加载时加载常量
2. 运行时通过string.intern()方法可将string置入常量池

### 7 直接内存

1. 不属于jvm规范定义的内存区，但是被频繁使用，会导致OOM
2. eg. NIO DirectByteBuffer会操作直接内存

## HotSpot对象
### 1 对象的创建

#### 类的加载

#### 内存分配
根据JAVA堆是否规整，回收算法是否带压缩整理功能，内存分配方式分为

1. 指针碰撞（bump to pointer）
2. 空闲列表（free list）

内存分配很频繁，要考虑多线程问题，解决方案有二：

1. 采用CAS和失败重试保证原子性
2. 每个线程预先分配TLAB(thread local allocation buffer),线程在各自TLAB上分配，当TLAB用完并重新分配TLAB时，才会同步加锁

#### 程序中的init方法调起

### 2 对象的内存布局

1. 对象头（运行时数据 + 类型指针）
2. 实例数据 包括父类和自身的字段，按照一定顺序分配
3. 对齐填充 对象大小必须是**8byte**的整数倍

### 3 对象的访问定位

根据reference来定位到对象，访问对象，有两种实现方式：

1. **句柄** java堆中划出句柄池，reference指向句柄，句柄包含了到对象实例数据和对象类型数据的地址
2. **直接地址** reference指向对象直接地址，包含对象类型数据的地址和对象实例数据

HotSpot采用方式2实现，效率更高


## 异常实战（待回看）
### 1 JAVA堆溢出
	-Xms 表示java虚拟机堆区内存初始内存分配的大小
	-Xmx 表示java虚拟机堆区内存可被分配的最大上限

1. jvm运行参数  "-XX:+HeapDumpOnOutOfMemoryError"，发生heap的OOM时，将heap的数据dump到文件快照
2. 将heap的dump使用工具分析，查看内存中对象是否必要，是memory leak还是memory overflow
3. memory leak则继续分析泄露对象到gc roots的引用链，定位到问题代码，分析为何gc没有回收掉内存
4. memory overflow则查看-Xms -Xmx 与当前机器物理内存，看是否可以调大参数；或优化代码，减少内存的消耗

### 2 JAVA虚拟机栈溢出
	-Xss 表示java虚拟机栈区内存初始内存分配的大小
	-Xoss 表示java本地方法栈区内存初始内存分配的大小（hotspot虚拟机无效，因为虚拟机栈和本地方法栈不区分）

### 3 方法区或常量池溢出
	-XX:PermSize 永久代大小
	-XX:MaxPermSize

### 4 直接内存溢出
